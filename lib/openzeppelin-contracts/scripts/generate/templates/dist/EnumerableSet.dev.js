"use strict";

var format = require('../format-lines');

var _require = require('./conversion'),
    fromBytes32 = _require.fromBytes32,
    toBytes32 = _require.toBytes32;

var TYPES = [{
  name: 'Bytes32Set',
  type: 'bytes32'
}, {
  name: 'AddressSet',
  type: 'address'
}, {
  name: 'UintSet',
  type: 'uint256'
}];
/* eslint-disable max-len */

var header = "pragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\n";
/* eslint-enable max-len */

var defaultSet = function defaultSet() {
  return "// To implement this library for multiple types with as little code\n// repetition as possible, we write it in terms of a generic Set type with\n// bytes32 values.\n// The Set implementation uses private functions, and user-facing\n// implementations (such as AddressSet) are just wrappers around the\n// underlying Set.\n// This means that we can only create new EnumerableSets for types that fit\n// in bytes32.\n\nstruct Set {\n    // Storage of set values\n    bytes32[] _values;\n    // Position of the value in the `values` array, plus 1 because index 0\n    // means a value is not in the set.\n    mapping(bytes32 => uint256) _indexes;\n}\n\n/**\n * @dev Add a value to a set. O(1).\n *\n * Returns true if the value was added to the set, that is if it was not\n * already present.\n */\nfunction _add(Set storage set, bytes32 value) private returns (bool) {\n    if (!_contains(set, value)) {\n        set._values.push(value);\n        // The value is stored at length-1, but we add 1 to all indexes\n        // and use 0 as a sentinel value\n        set._indexes[value] = set._values.length;\n        return true;\n    } else {\n        return false;\n    }\n}\n\n/**\n * @dev Removes a value from a set. O(1).\n *\n * Returns true if the value was removed from the set, that is if it was\n * present.\n */\nfunction _remove(Set storage set, bytes32 value) private returns (bool) {\n    // We read and store the value's index to prevent multiple reads from the same storage slot\n    uint256 valueIndex = set._indexes[value];\n\n    if (valueIndex != 0) {\n        // Equivalent to contains(set, value)\n        // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n        // the array, and then remove the last element (sometimes called as 'swap and pop').\n        // This modifies the order of the array, as noted in {at}.\n\n        uint256 toDeleteIndex = valueIndex - 1;\n        uint256 lastIndex = set._values.length - 1;\n\n        if (lastIndex != toDeleteIndex) {\n            bytes32 lastValue = set._values[lastIndex];\n\n            // Move the last value to the index where the value to delete is\n            set._values[toDeleteIndex] = lastValue;\n            // Update the index for the moved value\n            set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n        }\n\n        // Delete the slot where the moved value was stored\n        set._values.pop();\n\n        // Delete the index for the deleted slot\n        delete set._indexes[value];\n\n        return true;\n    } else {\n        return false;\n    }\n}\n\n/**\n * @dev Returns true if the value is in the set. O(1).\n */\nfunction _contains(Set storage set, bytes32 value) private view returns (bool) {\n    return set._indexes[value] != 0;\n}\n\n/**\n * @dev Returns the number of values on the set. O(1).\n */\nfunction _length(Set storage set) private view returns (uint256) {\n    return set._values.length;\n}\n\n/**\n * @dev Returns the value stored at position `index` in the set. O(1).\n *\n * Note that there are no guarantees on the ordering of values inside the\n * array, and it may change when more values are added or removed.\n *\n * Requirements:\n *\n * - `index` must be strictly less than {length}.\n */\nfunction _at(Set storage set, uint256 index) private view returns (bytes32) {\n    return set._values[index];\n}\n\n/**\n * @dev Return the entire set in an array\n *\n * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n */\nfunction _values(Set storage set) private view returns (bytes32[] memory) {\n    return set._values;\n}\n";
};

var customSet = function customSet(_ref) {
  var name = _ref.name,
      type = _ref.type;
  return "// ".concat(name, "\n\nstruct ").concat(name, " {\n    Set _inner;\n}\n\n/**\n * @dev Add a value to a set. O(1).\n *\n * Returns true if the value was added to the set, that is if it was not\n * already present.\n */\nfunction add(").concat(name, " storage set, ").concat(type, " value) internal returns (bool) {\n    return _add(set._inner, ").concat(toBytes32(type, 'value'), ");\n}\n\n/**\n * @dev Removes a value from a set. O(1).\n *\n * Returns true if the value was removed from the set, that is if it was\n * present.\n */\nfunction remove(").concat(name, " storage set, ").concat(type, " value) internal returns (bool) {\n    return _remove(set._inner, ").concat(toBytes32(type, 'value'), ");\n}\n\n/**\n * @dev Returns true if the value is in the set. O(1).\n */\nfunction contains(").concat(name, " storage set, ").concat(type, " value) internal view returns (bool) {\n    return _contains(set._inner, ").concat(toBytes32(type, 'value'), ");\n}\n\n/**\n * @dev Returns the number of values in the set. O(1).\n */\nfunction length(").concat(name, " storage set) internal view returns (uint256) {\n    return _length(set._inner);\n}\n\n/**\n * @dev Returns the value stored at position `index` in the set. O(1).\n *\n * Note that there are no guarantees on the ordering of values inside the\n * array, and it may change when more values are added or removed.\n *\n * Requirements:\n *\n * - `index` must be strictly less than {length}.\n */\nfunction at(").concat(name, " storage set, uint256 index) internal view returns (").concat(type, ") {\n    return ").concat(fromBytes32(type, '_at(set._inner, index)'), ";\n}\n\n/**\n * @dev Return the entire set in an array\n *\n * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n */\nfunction values(").concat(name, " storage set) internal view returns (").concat(type, "[] memory) {\n    bytes32[] memory store = _values(set._inner);\n    ").concat(type, "[] memory result;\n\n    /// @solidity memory-safe-assembly\n    assembly {\n        result := store\n    }\n\n    return result;\n}\n");
}; // GENERATE


module.exports = format(header.trimEnd(), 'library EnumerableSet {', [defaultSet(), TYPES.map(function (details) {
  return customSet(details).trimEnd();
}).join('\n\n')], '}');