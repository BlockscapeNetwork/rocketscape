"use strict";

var format = require('../format-lines');

var _require = require('./conversion'),
    fromBytes32 = _require.fromBytes32,
    toBytes32 = _require.toBytes32;

var TYPES = [{
  name: 'UintToUintMap',
  keyType: 'uint256',
  valueType: 'uint256'
}, {
  name: 'UintToAddressMap',
  keyType: 'uint256',
  valueType: 'address'
}, {
  name: 'AddressToUintMap',
  keyType: 'address',
  valueType: 'uint256'
}, {
  name: 'Bytes32ToUintMap',
  keyType: 'bytes32',
  valueType: 'uint256'
}];
/* eslint-disable max-len */

var header = "pragma solidity ^0.8.0;\n\nimport \"./EnumerableSet.sol\";\n\n/**\n * @dev Library for managing an enumerable variant of Solidity's\n * https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]\n * type.\n *\n * Maps have the following properties:\n *\n * - Entries are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Entries are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableMap for EnumerableMap.UintToAddressMap;\n *\n *     // Declare a set state variable\n *     EnumerableMap.UintToAddressMap private myMap;\n * }\n * ```\n *\n * The following map types are supported:\n *\n * - `uint256 -> address` (`UintToAddressMap`) since v3.0.0\n * - `address -> uint256` (`AddressToUintMap`) since v4.6.0\n * - `bytes32 -> bytes32` (`Bytes32ToBytes32Map`) since v4.6.0\n * - `uint256 -> uint256` (`UintToUintMap`) since v4.7.0\n * - `bytes32 -> uint256` (`Bytes32ToUintMap`) since v4.7.0\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableMap, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableMap.\n * ====\n */\n";
/* eslint-enable max-len */

var defaultMap = function defaultMap() {
  return "// To implement this library for multiple types with as little code\n// repetition as possible, we write it in terms of a generic Map type with\n// bytes32 keys and values.\n// The Map implementation uses private functions, and user-facing\n// implementations (such as Uint256ToAddressMap) are just wrappers around\n// the underlying Map.\n// This means that we can only create new EnumerableMaps for types that fit\n// in bytes32.\n\nstruct Bytes32ToBytes32Map {\n    // Storage of keys\n    EnumerableSet.Bytes32Set _keys;\n    mapping(bytes32 => bytes32) _values;\n}\n\n/**\n * @dev Adds a key-value pair to a map, or updates the value for an existing\n * key. O(1).\n *\n * Returns true if the key was added to the map, that is if it was not\n * already present.\n */\nfunction set(\n    Bytes32ToBytes32Map storage map,\n    bytes32 key,\n    bytes32 value\n) internal returns (bool) {\n    map._values[key] = value;\n    return map._keys.add(key);\n}\n\n/**\n * @dev Removes a key-value pair from a map. O(1).\n *\n * Returns true if the key was removed from the map, that is if it was present.\n */\nfunction remove(Bytes32ToBytes32Map storage map, bytes32 key) internal returns (bool) {\n    delete map._values[key];\n    return map._keys.remove(key);\n}\n\n/**\n * @dev Returns true if the key is in the map. O(1).\n */\nfunction contains(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bool) {\n    return map._keys.contains(key);\n}\n\n/**\n * @dev Returns the number of key-value pairs in the map. O(1).\n */\nfunction length(Bytes32ToBytes32Map storage map) internal view returns (uint256) {\n    return map._keys.length();\n}\n\n/**\n * @dev Returns the key-value pair stored at position `index` in the map. O(1).\n *\n * Note that there are no guarantees on the ordering of entries inside the\n * array, and it may change when more entries are added or removed.\n *\n * Requirements:\n *\n * - `index` must be strictly less than {length}.\n */\nfunction at(Bytes32ToBytes32Map storage map, uint256 index) internal view returns (bytes32, bytes32) {\n    bytes32 key = map._keys.at(index);\n    return (key, map._values[key]);\n}\n\n/**\n * @dev Tries to returns the value associated with `key`. O(1).\n * Does not revert if `key` is not in the map.\n */\nfunction tryGet(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bool, bytes32) {\n    bytes32 value = map._values[key];\n    if (value == bytes32(0)) {\n        return (contains(map, key), bytes32(0));\n    } else {\n        return (true, value);\n    }\n}\n\n/**\n * @dev Returns the value associated with `key`. O(1).\n *\n * Requirements:\n *\n * - `key` must be in the map.\n */\nfunction get(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bytes32) {\n    bytes32 value = map._values[key];\n    require(value != 0 || contains(map, key), \"EnumerableMap: nonexistent key\");\n    return value;\n}\n\n/**\n * @dev Same as {get}, with a custom error message when `key` is not in the map.\n *\n * CAUTION: This function is deprecated because it requires allocating memory for the error\n * message unnecessarily. For custom revert reasons use {tryGet}.\n */\nfunction get(\n    Bytes32ToBytes32Map storage map,\n    bytes32 key,\n    string memory errorMessage\n) internal view returns (bytes32) {\n    bytes32 value = map._values[key];\n    require(value != 0 || contains(map, key), errorMessage);\n    return value;\n}\n";
};

var customMap = function customMap(_ref) {
  var name = _ref.name,
      keyType = _ref.keyType,
      valueType = _ref.valueType;
  return "// ".concat(name, "\n\nstruct ").concat(name, " {\n    Bytes32ToBytes32Map _inner;\n}\n\n/**\n * @dev Adds a key-value pair to a map, or updates the value for an existing\n * key. O(1).\n *\n * Returns true if the key was added to the map, that is if it was not\n * already present.\n */\nfunction set(\n    ").concat(name, " storage map,\n    ").concat(keyType, " key,\n    ").concat(valueType, " value\n) internal returns (bool) {\n    return set(map._inner, ").concat(toBytes32(keyType, 'key'), ", ").concat(toBytes32(valueType, 'value'), ");\n}\n\n/**\n * @dev Removes a value from a set. O(1).\n *\n * Returns true if the key was removed from the map, that is if it was present.\n */\nfunction remove(").concat(name, " storage map, ").concat(keyType, " key) internal returns (bool) {\n    return remove(map._inner, ").concat(toBytes32(keyType, 'key'), ");\n}\n\n/**\n * @dev Returns true if the key is in the map. O(1).\n */\nfunction contains(").concat(name, " storage map, ").concat(keyType, " key) internal view returns (bool) {\n    return contains(map._inner, ").concat(toBytes32(keyType, 'key'), ");\n}\n\n/**\n * @dev Returns the number of elements in the map. O(1).\n */\nfunction length(").concat(name, " storage map) internal view returns (uint256) {\n    return length(map._inner);\n}\n\n/**\n * @dev Returns the element stored at position `index` in the set. O(1).\n * Note that there are no guarantees on the ordering of values inside the\n * array, and it may change when more values are added or removed.\n *\n * Requirements:\n *\n * - `index` must be strictly less than {length}.\n */\nfunction at(").concat(name, " storage map, uint256 index) internal view returns (").concat(keyType, ", ").concat(valueType, ") {\n    (bytes32 key, bytes32 value) = at(map._inner, index);\n    return (").concat(fromBytes32(keyType, 'key'), ", ").concat(fromBytes32(valueType, 'value'), ");\n}\n\n/**\n * @dev Tries to returns the value associated with `key`. O(1).\n * Does not revert if `key` is not in the map.\n */\nfunction tryGet(").concat(name, " storage map, ").concat(keyType, " key) internal view returns (bool, ").concat(valueType, ") {\n    (bool success, bytes32 value) = tryGet(map._inner, ").concat(toBytes32(keyType, 'key'), ");\n    return (success, ").concat(fromBytes32(valueType, 'value'), ");\n}\n\n/**\n * @dev Returns the value associated with `key`. O(1).\n *\n * Requirements:\n *\n * - `key` must be in the map.\n */\nfunction get(").concat(name, " storage map, ").concat(keyType, " key) internal view returns (").concat(valueType, ") {\n    return ").concat(fromBytes32(valueType, "get(map._inner, ".concat(toBytes32(keyType, 'key'), ")")), ";\n}\n\n/**\n * @dev Same as {get}, with a custom error message when `key` is not in the map.\n *\n * CAUTION: This function is deprecated because it requires allocating memory for the error\n * message unnecessarily. For custom revert reasons use {tryGet}.\n */\nfunction get(\n    ").concat(name, " storage map,\n    ").concat(keyType, " key,\n    string memory errorMessage\n) internal view returns (").concat(valueType, ") {\n    return ").concat(fromBytes32(valueType, "get(map._inner, ".concat(toBytes32(keyType, 'key'), ", errorMessage)")), ";\n}\n");
}; // GENERATE


module.exports = format(header.trimEnd(), 'library EnumerableMap {', ['using EnumerableSet for EnumerableSet.Bytes32Set;', '', defaultMap(), TYPES.map(function (details) {
  return customMap(details).trimEnd();
}).join('\n\n')], '}');